import { IAgentRuntime, Service } from "@elizaos/core";
import { execFile } from "child_process";
import { promisify } from "util";
import * as path from "path";
import { promises as fs } from "fs";
import { watch } from "fs";

const execFileAsync = promisify(execFile);

export class GaussianKnowledgeService extends Service {
    capabilityDescription = "Automatically monitors example_logs directory, parses Gaussian files, and maintains a persistent knowledge graph for querying";
    
    private runtime!: IAgentRuntime;
    private knowledgeGraphPath: string;
    private watchedDirectory: string;
    private processedFiles: Set<string> = new Set();
    private isInitialized = false;

    constructor() {
        super();
        this.knowledgeGraphPath = "";
        this.watchedDirectory = "";
    }

    static async start(runtime: IAgentRuntime): Promise<GaussianKnowledgeService> {
        const service = new GaussianKnowledgeService();
        await service.initialize(runtime);
        console.log("üß† Gaussian Knowledge Service started - monitoring example_logs/");
        return service;
    }

    async initialize(runtime: IAgentRuntime): Promise<void> {
        if (this.isInitialized) return;

        this.runtime = runtime;
        
        // Set up paths
        this.knowledgeGraphPath = path.join(process.cwd(), "data", "gaussian-knowledge-graph.ttl");
        this.watchedDirectory = path.join(process.cwd(), "example_logs");

        try {
            // Ensure data directory exists
            await fs.mkdir(path.dirname(this.knowledgeGraphPath), { recursive: true });
            
            // Ensure example_logs directory exists
            await fs.mkdir(this.watchedDirectory, { recursive: true });
            
            // Load existing knowledge graph or create new one
            await this.loadOrCreateKnowledgeGraph();
            
            // Scan existing files in example_logs
            await this.scanExistingFiles();
            
            // Start monitoring for new files
            this.startFileWatcher();
            
            this.isInitialized = true;
            console.log(`üìä Knowledge graph initialized: ${this.knowledgeGraphPath}`);
            console.log(`üëÄ Watching directory: ${this.watchedDirectory}`);
            
        } catch (error) {
            console.error("‚ùå Failed to initialize Gaussian Knowledge Service:", error);
        }
    }

    async stop(): Promise<void> {
        console.log("üß† Gaussian Knowledge Service stopped");
    }

    private async loadOrCreateKnowledgeGraph(): Promise<void> {
        try {
            const stats = await fs.stat(this.knowledgeGraphPath);
            if (stats.isFile()) {
                console.log("üìñ Loading existing knowledge graph...");
                const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
                console.log(`üìä Loaded knowledge graph (${content.length} bytes)`);
            }
        } catch (error) {
            // File doesn't exist, create initial knowledge graph
            console.log("üÜï Creating new knowledge graph...");
            await this.createInitialKnowledgeGraph();
        }
    }

    private async createInitialKnowledgeGraph(): Promise<void> {
        const initialRDF = `@prefix cheminf: <http://semanticscience.org/resource/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix ex: <https://example.org/gaussian#> .
@prefix ontocompchem: <http://www.theworldavatar.com/ontology/ontocompchem/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# Gaussian Knowledge Graph - Auto-generated by ElizaOS Gaussian Plugin
# Created: ${new Date().toISOString()}

`;
        await fs.writeFile(this.knowledgeGraphPath, initialRDF, 'utf-8');
        console.log("‚úÖ Initial knowledge graph created");
    }

    private async scanExistingFiles(): Promise<void> {
        try {
            const files = await fs.readdir(this.watchedDirectory);
            const gaussianFiles = files.filter(file => 
                file.toLowerCase().endsWith('.log') || 
                file.toLowerCase().endsWith('.out')
            );

            console.log(`üîç Found ${gaussianFiles.length} Gaussian files to process`);

            for (const file of gaussianFiles) {
                await this.processGaussianFile(path.join(this.watchedDirectory, file));
            }

            console.log(`‚úÖ Processed ${gaussianFiles.length} existing files`);
        } catch (error) {
            console.error("‚ùå Error scanning existing files:", error);
        }
    }

    private startFileWatcher(): void {
        watch(this.watchedDirectory, { recursive: false }, async (eventType, filename) => {
            if (!filename) return;
            
            const filePath = path.join(this.watchedDirectory, filename);
            
            // Only process Gaussian files
            if (!filename.toLowerCase().endsWith('.log') && !filename.toLowerCase().endsWith('.out')) {
                return;
            }

            if (eventType === 'rename' || eventType === 'change') {
                try {
                    // Check if file exists (could be deletion)
                    await fs.access(filePath);
                    
                    // Skip if already processed
                    if (this.processedFiles.has(filePath)) {
                        return;
                    }

                    console.log(`üÜï New Gaussian file detected: ${filename}`);
                    await this.processGaussianFile(filePath);
                    
                } catch (error) {
                    // File was deleted or is inaccessible
                    console.log(`üóëÔ∏è  File removed or inaccessible: ${filename}`);
                }
            }
        });
    }

    private async processGaussianFile(filePath: string): Promise<void> {
        try {
            // Skip if already processed
            if (this.processedFiles.has(filePath)) {
                return;
            }

            console.log(`‚öôÔ∏è  Processing: ${path.basename(filePath)}`);

            // Call Python parser
            const pythonScript = path.join(process.cwd(), "py", "parse_gaussian.py");
            const metadata = {
                filename: path.basename(filePath),
                timestamp: new Date().toISOString(),
                source: "auto-scan"
            };

            const { stdout: rdfOutput } = await execFileAsync("python3", [
                pythonScript,
                filePath,
                JSON.stringify(metadata),
                "--format", "turtle"
            ]);

            // Append to knowledge graph
            await this.appendToKnowledgeGraph(rdfOutput, filePath);
            
            // Mark as processed
            this.processedFiles.add(filePath);
            
            const tripleCount = (rdfOutput.match(/\./g) || []).length;
            console.log(`‚úÖ Added ${tripleCount} triples from ${path.basename(filePath)}`);

        } catch (error) {
            console.error(`‚ùå Error processing ${path.basename(filePath)}:`, error);
        }
    }

    private async appendToKnowledgeGraph(rdfContent: string, sourcePath: string): Promise<void> {
        try {
            // Add comment header for this file
            const header = `\n# Data from: ${path.basename(sourcePath)} (processed ${new Date().toISOString()})\n`;
            const contentToAppend = header + rdfContent + '\n';
            
            await fs.appendFile(this.knowledgeGraphPath, contentToAppend, 'utf-8');
        } catch (error) {
            console.error("‚ùå Error appending to knowledge graph:", error);
        }
    }

    async queryKnowledgeGraph(query: string): Promise<any> {
        try {
            // For now, return basic stats and grep-style search
            // In a full implementation, this would use a proper SPARQL engine
            
            const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
            
            // Basic statistics
            const stats = {
                totalTriples: (content.match(/\./g) || []).length,
                molecules: (content.match(/ontocompchem:QuantumCalculation/g) || []).length,
                scfEnergies: (content.match(/ontocompchem:hasSCFEnergy/g) || []).length,
                frequencies: (content.match(/ontocompchem:hasFrequency/g) || []).length,
                atoms: (content.match(/cheminf:hasAtom/g) || []).length
            };

            // Simple text search for queries
            const queryLower = query.toLowerCase();
            const lines = content.split('\n');
            const relevantLines = lines.filter(line => 
                line.toLowerCase().includes(queryLower) ||
                (queryLower.includes('energy') && line.includes('ontocompchem:hasSCFEnergy')) ||
                (queryLower.includes('homo') && line.includes('ontocompchem:hasHOMOLUMOGap')) ||
                (queryLower.includes('frequency') && line.includes('ontocompchem:hasFrequency')) ||
                (queryLower.includes('atom') && line.includes('cheminf:hasAtom'))
            );

            return {
                stats,
                relevantData: relevantLines.slice(0, 10), // Limit results
                query: query
            };

        } catch (error) {
            console.error("‚ùå Error querying knowledge graph:", error);
            return { error: error.message };
        }
    }

    async getKnowledgeGraphStats(): Promise<any> {
        try {
            const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
            const stats = await fs.stat(this.knowledgeGraphPath);
            
            return {
                fileSize: stats.size,
                totalTriples: (content.match(/\./g) || []).length,
                molecules: (content.match(/ontocompchem:QuantumCalculation/g) || []).length,
                scfEnergies: (content.match(/ontocompchem:hasSCFEnergy/g) || []).length,
                homoLumoGaps: (content.match(/ontocompchem:hasHOMOLUMOGap/g) || []).length,
                frequencies: (content.match(/ontocompchem:hasFrequency/g) || []).length,
                atoms: (content.match(/cheminf:hasAtom/g) || []).length,
                processedFiles: this.processedFiles.size,
                lastModified: stats.mtime
            };
        } catch (error) {
            console.error("‚ùå Error getting knowledge graph stats:", error);
            return { error: error.message };
        }
    }
} 