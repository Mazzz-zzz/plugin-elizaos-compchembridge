import { IAgentRuntime, Service } from "@elizaos/core";
import { execFile } from "child_process";
import { promisify } from "util";
import * as path from "path";
import { promises as fs } from "fs";
import { watch } from "fs";

const execFileAsync = promisify(execFile);

export class GaussianKnowledgeService extends Service {
    capabilityDescription = "Automatically monitors example_logs directory, parses Gaussian files using cclib, and maintains a comprehensive knowledge graph for querying";
    
    private runtime!: IAgentRuntime;
    private knowledgeGraphPath: string;
    private watchedDirectory: string;
    private processedFiles: Set<string> = new Set();
    private isInitialized = false;
    private cclibAvailable = false;

    constructor() {
        super();
        this.knowledgeGraphPath = "";
        this.watchedDirectory = "";
    }

    static async start(runtime: IAgentRuntime): Promise<GaussianKnowledgeService> {
        const service = new GaussianKnowledgeService();
        await service.initialize(runtime);
        console.log("üß† Gaussian Knowledge Service started - monitoring example_logs/ with cclib parsing");
        return service;
    }

    async initialize(runtime: IAgentRuntime): Promise<void> {
        if (this.isInitialized) return;

        this.runtime = runtime;
        
        // Set up paths
        this.knowledgeGraphPath = path.join(process.cwd(), "data", "gaussian-knowledge-graph.ttl");
        this.watchedDirectory = path.join(process.cwd(), "example_logs");

        try {
            // Check if cclib is available
            await this.checkCclibAvailability();
            
            // Ensure data directory exists
            await fs.mkdir(path.dirname(this.knowledgeGraphPath), { recursive: true });
            
            // Ensure example_logs directory exists
            await fs.mkdir(this.watchedDirectory, { recursive: true });
            
            // Load existing knowledge graph or create new one
            await this.loadOrCreateKnowledgeGraph();
            
            // Scan existing files in example_logs
            await this.scanExistingFiles();
            
            // Start monitoring for new files
            this.startFileWatcher();
            
            this.isInitialized = true;
            console.log(`üìä Knowledge graph initialized: ${this.knowledgeGraphPath}`);
            console.log(`üëÄ Watching directory: ${this.watchedDirectory}`);
            console.log(`üî¨ cclib parser: ${this.cclibAvailable ? '‚úÖ Available' : '‚ùå Not available'}`);
            
        } catch (error) {
            console.error("‚ùå Failed to initialize Gaussian Knowledge Service:", error);
        }
    }

    async stop(): Promise<void> {
        console.log("üß† Gaussian Knowledge Service stopped");
    }

    private async checkCclibAvailability(): Promise<void> {
        try {
            const pythonScript = path.join(process.cwd(), "py", "parse_gaussian_cclib.py");
            await fs.access(pythonScript);
            
            // Test cclib import
            const { stdout } = await execFileAsync("python3", ["-c", "import cclib; print(cclib.__version__)"]);
            console.log(`üî¨ cclib version detected: ${stdout.trim()}`);
            this.cclibAvailable = true;
        } catch (error) {
            console.warn("‚ö†Ô∏è  cclib not available, falling back to basic parsing:", error.message);
            this.cclibAvailable = false;
        }
    }

    private async loadOrCreateKnowledgeGraph(): Promise<void> {
        try {
            const stats = await fs.stat(this.knowledgeGraphPath);
            if (stats.isFile()) {
                console.log("üìñ Loading existing knowledge graph...");
                const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
                console.log(`üìä Loaded knowledge graph (${content.length} bytes)`);
            }
        } catch (error) {
            // File doesn't exist, create initial knowledge graph
            console.log("üÜï Creating new knowledge graph...");
            await this.createInitialKnowledgeGraph();
        }
    }

    private async createInitialKnowledgeGraph(): Promise<void> {
        const initialRDF = `@prefix cheminf: <http://semanticscience.org/resource/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix ex: <https://example.org/gaussian#> .
@prefix ontocompchem: <http://www.theworldavatar.com/ontology/ontocompchem/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix units: <http://www.ontology-of-units-of-measure.org/resource/om-2/> .

# Gaussian Knowledge Graph - Auto-generated by ElizaOS Gaussian Plugin with cclib
# Created: ${new Date().toISOString()}

`;
        await fs.writeFile(this.knowledgeGraphPath, initialRDF, 'utf-8');
        console.log("‚úÖ Initial knowledge graph created");
    }

    private async scanExistingFiles(): Promise<void> {
        try {
            const files = await fs.readdir(this.watchedDirectory);
            const gaussianFiles = files.filter(file => 
                file.toLowerCase().endsWith('.log') || 
                file.toLowerCase().endsWith('.out')
            );

            console.log(`üîç Found ${gaussianFiles.length} Gaussian files to process`);

            for (const file of gaussianFiles) {
                await this.processGaussianFile(path.join(this.watchedDirectory, file));
            }

            console.log(`‚úÖ Processed ${gaussianFiles.length} existing files`);
        } catch (error) {
            console.error("‚ùå Error scanning existing files:", error);
        }
    }

    private startFileWatcher(): void {
        watch(this.watchedDirectory, { recursive: false }, async (eventType, filename) => {
            if (!filename) return;
            
            const filePath = path.join(this.watchedDirectory, filename);
            
            // Only process Gaussian files
            if (!filename.toLowerCase().endsWith('.log') && !filename.toLowerCase().endsWith('.out')) {
                return;
            }

            if (eventType === 'rename' || eventType === 'change') {
                try {
                    // Check if file exists (could be deletion)
                    await fs.access(filePath);
                    
                    // Skip if already processed
                    if (this.processedFiles.has(filePath)) {
                        return;
                    }

                    console.log(`üÜï New Gaussian file detected: ${filename}`);
                    await this.processGaussianFile(filePath);
                    
                } catch (error) {
                    // File was deleted or is inaccessible
                    console.log(`üóëÔ∏è  File removed or inaccessible: ${filename}`);
                }
            }
        });
    }

    private async processGaussianFile(filePath: string): Promise<void> {
        try {
            // Skip if already processed
            if (this.processedFiles.has(filePath)) {
                return;
            }

            console.log(`‚öôÔ∏è  Processing: ${path.basename(filePath)}`);

            const metadata = {
                filename: path.basename(filePath),
                timestamp: new Date().toISOString(),
                source: "auto-scan",
                parser: this.cclibAvailable ? "cclib" : "basic"
            };

            let rdfOutput: string;

            if (this.cclibAvailable) {
                // Use cclib parser
                const pythonScript = path.join(process.cwd(), "py", "parse_gaussian_cclib.py");
                const { stdout } = await execFileAsync("python3", [
                    pythonScript,
                    filePath,
                    JSON.stringify(metadata),
                    "--format", "turtle"
                ]);
                rdfOutput = stdout;
            } else {
                // Fallback to basic parsing
                const pythonScript = path.join(process.cwd(), "py", "parse_gaussian.py");
                const { stdout } = await execFileAsync("python3", [
                    pythonScript,
                    filePath,
                    JSON.stringify(metadata),
                    "--format", "turtle"
                ]);
                rdfOutput = stdout;
            }

            // Append to knowledge graph
            await this.appendToKnowledgeGraph(rdfOutput, filePath);
            
            // Mark as processed
            this.processedFiles.add(filePath);
            
            const tripleCount = (rdfOutput.match(/\./g) || []).length;
            console.log(`‚úÖ Added ${tripleCount} triples from ${path.basename(filePath)} using ${this.cclibAvailable ? 'cclib' : 'basic'} parser`);

        } catch (error) {
            console.error(`‚ùå Error processing ${path.basename(filePath)}:`, error);
        }
    }

    private async appendToKnowledgeGraph(rdfContent: string, sourcePath: string): Promise<void> {
        try {
            // Add comment header for this file
            const header = `\n# Data from: ${path.basename(sourcePath)} (processed ${new Date().toISOString()})\n`;
            const contentToAppend = header + rdfContent + '\n';
            
            await fs.appendFile(this.knowledgeGraphPath, contentToAppend, 'utf-8');
        } catch (error) {
            console.error("‚ùå Error appending to knowledge graph:", error);
        }
    }

    async queryKnowledgeGraph(query: string): Promise<any> {
        try {
            const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
            
            // Enhanced statistics with cclib data
            const stats = {
                totalTriples: (content.match(/\./g) || []).length,
                molecules: (content.match(/ontocompchem:QuantumCalculation/g) || []).length,
                scfEnergies: (content.match(/ontocompchem:hasSCFEnergy/g) || []).length,
                homoLumoGaps: (content.match(/ontocompchem:hasHOMOLUMOGap/g) || []).length,
                frequencies: (content.match(/ontocompchem:hasFrequency/g) || []).length,
                atoms: (content.match(/cheminf:Atom/g) || []).length,
                // Enhanced cclib properties
                thermochemistry: {
                    enthalpy: (content.match(/ontocompchem:hasEnthalpy/g) || []).length,
                    entropy: (content.match(/ontocompchem:hasEntropy/g) || []).length,
                    freeEnergy: (content.match(/ontocompchem:hasFreeEnergy/g) || []).length,
                    zpve: (content.match(/ontocompchem:hasZPVE/g) || []).length
                },
                spectroscopy: {
                    transitions: (content.match(/ontocompchem:ElectronicTransition/g) || []).length,
                    irIntensities: (content.match(/ontocompchem:hasIRIntensity/g) || []).length,
                    ramanActivities: (content.match(/ontocompchem:hasRamanActivity/g) || []).length
                },
                basis: {
                    molecularOrbitals: (content.match(/ontocompchem:hasNumberOfMOs/g) || []).length,
                    basisFunctions: (content.match(/ontocompchem:hasNumberOfBasisFunctions/g) || []).length
                }
            };

            // Simple text search for queries with enhanced patterns
            const queryLower = query.toLowerCase();
            const lines = content.split('\n');
            const relevantLines = lines.filter(line => {
                const lineLower = line.toLowerCase();
                return lineLower.includes(queryLower) ||
                    (queryLower.includes('energy') && (
                        line.includes('ontocompchem:hasSCFEnergy') ||
                        line.includes('ontocompchem:hasEnthalpy') ||
                        line.includes('ontocompchem:hasFreeEnergy')
                    )) ||
                    (queryLower.includes('homo') && line.includes('ontocompchem:hasHOMOLUMOGap')) ||
                    (queryLower.includes('frequency') && line.includes('ontocompchem:hasFrequency')) ||
                    (queryLower.includes('atom') && line.includes('cheminf:Atom')) ||
                    (queryLower.includes('thermochem') && (
                        line.includes('ontocompchem:hasEnthalpy') ||
                        line.includes('ontocompchem:hasEntropy')
                    )) ||
                    (queryLower.includes('transition') && line.includes('ontocompchem:ElectronicTransition')) ||
                    (queryLower.includes('orbital') && line.includes('ontocompchem:hasNumberOfMOs'))
            });

            return {
                stats,
                relevantData: relevantLines.slice(0, 15), // Increased limit for richer data
                query: query,
                enhanced: this.cclibAvailable
            };

        } catch (error) {
            console.error("‚ùå Error querying knowledge graph:", error);
            return { error: error.message };
        }
    }

    async getKnowledgeGraphStats(): Promise<any> {
        try {
            const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
            const stats = await fs.stat(this.knowledgeGraphPath);
            
            // Comprehensive statistics including cclib-specific data
            const basicStats = {
                fileSize: stats.size,
                totalTriples: (content.match(/\./g) || []).length,
                molecules: (content.match(/ontocompchem:QuantumCalculation/g) || []).length,
                scfEnergies: (content.match(/ontocompchem:hasSCFEnergy/g) || []).length,
                homoLumoGaps: (content.match(/ontocompchem:hasHOMOLUMOGap/g) || []).length,
                frequencies: (content.match(/ontocompchem:hasFrequency/g) || []).length,
                atoms: (content.match(/cheminf:Atom/g) || []).length,
                processedFiles: this.processedFiles.size,
                lastModified: stats.mtime,
                parser: this.cclibAvailable ? "cclib" : "basic"
            };

            if (this.cclibAvailable) {
                // Add enhanced statistics for cclib data
                return {
                    ...basicStats,
                    enhanced: true,
                    thermochemistry: {
                        enthalpy: (content.match(/ontocompchem:hasEnthalpy/g) || []).length,
                        entropy: (content.match(/ontocompchem:hasEntropy/g) || []).length,
                        freeEnergy: (content.match(/ontocompchem:hasFreeEnergy/g) || []).length,
                        zpve: (content.match(/ontocompchem:hasZPVE/g) || []).length
                    },
                    spectroscopy: {
                        electronicTransitions: (content.match(/ontocompchem:ElectronicTransition/g) || []).length,
                        irIntensities: (content.match(/ontocompchem:hasIRIntensity/g) || []).length,
                        ramanActivities: (content.match(/ontocompchem:hasRamanActivity/g) || []).length,
                        oscillatorStrengths: (content.match(/ontocompchem:hasOscillatorStrength/g) || []).length
                    },
                    basisSet: {
                        molecularOrbitals: (content.match(/ontocompchem:hasNumberOfMOs/g) || []).length,
                        basisFunctions: (content.match(/ontocompchem:hasNumberOfBasisFunctions/g) || []).length,
                        atomicOrbitals: (content.match(/ontocompchem:hasAOCount/g) || []).length
                    },
                    optimization: {
                        convergedCalculations: (content.match(/ontocompchem:hasOptimizationConverged true/g) || []).length,
                        failedOptimizations: (content.match(/ontocompchem:hasOptimizationConverged false/g) || []).length
                    },
                    charges: {
                        atomicCharges: (content.match(/Charge/g) || []).length
                    },
                    molecularProperties: {
                        molecularFormulas: (content.match(/ontocompchem:hasMolecularFormula/g) || []).length,
                        charges: (content.match(/ontocompchem:hasCharge/g) || []).length,
                        multiplicities: (content.match(/ontocompchem:hasMultiplicity/g) || []).length
                    }
                };
            }

            return basicStats;
        } catch (error) {
            console.error("‚ùå Error getting knowledge graph stats:", error);
            return { error: error.message };
        }
    }

    // New method to get detailed cclib data for advanced analysis
    async getCclibDataSummary(): Promise<any> {
        if (!this.cclibAvailable) {
            return { error: "cclib not available" };
        }

        try {
            const content = await fs.readFile(this.knowledgeGraphPath, 'utf-8');
            
            // Extract specific numerical data for analysis
            const energyMatches = content.match(/ontocompchem:hasSCFEnergy (-?\d+\.?\d*)/g);
            const gapMatches = content.match(/ontocompchem:hasHOMOLUMOGap (-?\d+\.?\d*)/g);
            const freqMatches = content.match(/ontocompchem:hasFrequency (-?\d+\.?\d*)/g);
            
            const energies = energyMatches ? energyMatches.map(m => parseFloat(m.split(' ')[1])) : [];
            const gaps = gapMatches ? gapMatches.map(m => parseFloat(m.split(' ')[1])) : [];
            const frequencies = freqMatches ? freqMatches.map(m => parseFloat(m.split(' ')[1])) : [];
            
            return {
                enhanced: true,
                numerical_data: {
                    scf_energies: energies,
                    homo_lumo_gaps: gaps,
                    vibrational_frequencies: frequencies,
                    statistics: {
                        energy_range: energies.length > 0 ? {
                            min: Math.min(...energies),
                            max: Math.max(...energies),
                            mean: energies.reduce((a, b) => a + b, 0) / energies.length
                        } : null,
                        gap_range: gaps.length > 0 ? {
                            min: Math.min(...gaps),
                            max: Math.max(...gaps),
                            mean: gaps.reduce((a, b) => a + b, 0) / gaps.length
                        } : null,
                        frequency_range: frequencies.length > 0 ? {
                            min: Math.min(...frequencies),
                            max: Math.max(...frequencies),
                            imaginary_count: frequencies.filter(f => f < 0).length
                        } : null
                    }
                }
            };
        } catch (error) {
            return { error: error.message };
        }
    }
} 